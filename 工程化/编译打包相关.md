1. esbuild 为什么编译比 babel 快10-100倍？
    ```text
    1. 语言优势 esbuild 是 go（静态语言） 编写，babel是JavaScript（动态语言）编写的
    2. go 编译后是 二进制文件运行的，JavaScript是在v8虚拟机（node.js）中运行的
    3. 其次还有go无解释器开销，js编译为字节码；go本来支持多线程，js语言是单线程，多线程实现依赖其他工具；
    4. esbuild只需要一次解析生成AST语法树，然后其他的转义、压缩、代码生成都在一次遍历中完成。babel每个插件都会编译AST，每个插件都可能返回新的
    AST对象，消耗的内存和路径都比较长。
    综上，Babel和esbuild只是定位不同。babel设计的目标不是为了快，而是灵活性，转译基础设施。esbuild的快是牺牲了灵活性、兼容性换来的。
    ```
2. 现在的webpack构建还都是babel编译吗？
    ```text
    babel是主流，但也发展出了esbuild的 esbuild-loader、 SWC（性能接近esbuild）、typescript 官方编译器。所以现在大部分都是这些方案的组合
    使用，主要是为了兼容以前的commonjs写法、部分使用小众语法、提案的库。
    ```
3. 现代浏览器天然支持esbuild是为什么呢？
    ```text
    并非天然支持，esbuild编译目标是按现代浏览器的原生能力、标准、语法对齐的。
    其次，esbuild默认不做过度转译、冗余
    ```
   
4. rollup打包和webpack打包的区别在哪？ 
    ```text
    1. rollup 专注与多个文件打包为单一文件，追求产物精简（一般面相于库/框架的打包）。webpack多适用于全场景打包；
    2. rollup 支持esModule，天然支持tree-shaking。webpack为了兼容commonJs，因此静态分析能力会略差一点。
    3. rollup是但入口，单产物。webpack可以多模块合并，运行时注入。
    4. rollup默认不支持静态资源、无热更新、不支持devServer。webpack内置loader可以处理各种资源，还有联邦模块、热更新等
    综上，构建库用rollup，做应用选择webpack。
    ```

5. rollup支持动态import的分析吗，这个是如何实现的？
    ```text
    rollup是支持动态import分析的。
    1. 动态导入分为静态可分析的导入 import('./utils.js')，和半动态的 import(`${name}.js`) ，rollup对这两种的处理会略有区别；
    2. AST 解析阶段识别所有的上述 import 节点，将其分类；
    3. 对于静态可分析的import，拆分为独立的chunk，标记为异步chunk，不合并到主chunk文件当中去，同时在主chunk中注入加载的逻辑；
    4. 对于动态的import，先模糊分析（比如基于文件系统匹配可能的模块），生成【预打包chunk】，同时保留运行时的动态解析逻辑；
    5. chunk拆分与依赖图谱构建。rollup构建异步chunk的完整依赖兔皮，处理公共依赖的提取（多个异步chunk依赖同一个chunk，则提取为公共chunk）；
    6. 对于可以模糊路径匹配的文件，会全部打包到【预编译chunk】，当运行的变量和文件名匹配的时候，直接加载【预编译chunk】的文件；
    7. 完全动态的无法模糊匹配的文件，不会打包任何未知的模块，保留import语法，依赖浏览器/node.js的import解析语法完成加载；
    ```
   
6. rollup的模糊匹配路径生成的【预编译chunk】，如果该路径匹配的文件过多过大怎么办？
   ```text
   如果动态import使用不当，确实会造成这种情况。
   需要开发者从缩小范围、include/exclude 限定匹配文件范围
   ```
