### MCP(Model Context Protocol)模型上下文协议
```text
模型一般只能回答问题，或者Prompt调用工具，MCP是让模型操作外部工具的标准化的交互协议。规定交互的通信，使大语言模型能够安全、高效的访问、操作
外部资源(数据库查询、调用API)。
```

### 知识库
```text
核心：存&查
为AI智能体设计的结构化的知识存储与检索系统。大模型的上下文长度有限，所以一般会将信息进行向量化（可以帮助计算机理解相似度）后存储。
特点：
1. 通常是可以结构化形式存储的信息，便于查找检索；
2. 通常是更新频率比较低的静态信息；
```

### RAG(Retrieval-augmented-Generation)结合外部知识检索与大语言模型生成技术
```text
核心：问&答
在此之前，大模型存在这些问题：
1. 幻觉/偏差：LLM遇到不知道的事情会出现幻觉，会『捏造』不存在的事实；
2. 知识更新滞后：大模型的知识来源于当时的训练数据，之后的事情无法掌握；
3. 内容不可追溯性：LLM生成的内容缺乏明确的信息来源，影响信息的可信度；
4. 专业领域知识欠缺：通用的LLM对特定行业、个人私有知识库无法了解；

RAG的工作流程大致分为数据准备与用户提问2个部分:
数据准备流程：分片、索引（数据embedding向量化、原始文本与向量存储在向量数据库）；
用户提问：
1. 召回：搜索与用户问题相关的片段。用户的问题发给embedding模型，模型转换成向量，将向量发给向量数据库，找出TopK个最相似的结果。其中计算相似
度通常分为2种方法：余弦相似度（计算两个向量的余弦夹角，只关注方向）、欧式距离（与余弦相似度差异是考虑了向量的长度）。其中余弦相似度还可以简化
为点积（简单理解为向量1在向量2方向上的投影长度x向量2，关注距离和方向）；
2. 重排：从召回的TopK结果里面挑选3份最相似的作为重排的结果。
选择召回+重排的原因是召回使用向量相似度来计算相似度（成本低、速度快、准确率低），重排阶段使用cross-encoder计算相似度（成本高、速度慢、准
确率高）
3. 生成：将重排阶段生成的结果发给大模型，大模型生成回答给用户。

RAG有什么主要缺点？
1. 极度依赖高质量、可解析的结构化/非结构化的数据，且多模态支持技术不够成熟（视频、音频、图像）
2. 文档分块导致关键信息截断，无法整合内容，无法正确回答
3. 存储负担，知识库维护负担
```

### Rules 
```text
Rules指的是一套预定义的、准确性的逻辑、约束或业务流程。解决 AI 应用架构过程中行为不可控、不遵守预设逻辑的问题的补充规则（可以类比为交通法
规、汽车安全程序、预设行程等）。
```


### Prompt
```text
引导大模型的内部推理逻辑，可以作用于大模型本身、定义输出格式、交互范式。主要作用是引导大模型怎么做，告诉大模型内在推理逻辑、理解角色、任务
范式、输出格式。
```

### AG-UI协议
```text
AG-UI 协议是用于智能体与用户界面应用程序之间的交互协议。解决各种AI工具协议不统一，以及用户交互协议适配的问题。目前支持多种AI工具，多种语言，
处于活跃发展的过程中。
```

### ReAct(Reasoning and Acting)
```text
ReAct 是目前最为广泛的Agent运行模式。提交问题 -> (Thought-> Action -> Observation)重复若干次 -> Final Answer 输出结果
实现流程 
1. 设计提示词：
    你需要解决一个任务。为此你需要将任务分解成为多个步骤。对于每个步骤，首先使用<thought> 思考做什么，然后使用<action>调用工具，工具的执行结果会
    通过<observation>返回给你。持续的执行思考和行动的过程，直到你有足够的信息来回答<final_answer>。
    所有步骤严格使用以下XML标签输出：
    <task>：用户提出任务
    <thought>：思考
    <action>：采取的工具操作
    <observation>：工具或环境返回的结果
    <final_answer>：最终答案

2. 给出1-2个示例让模型模仿
3. 可用工具（比如读取文件、输出文件）
4. 注意事项
5. 环境信息


```

### 先规划再执行 Plan-and-Execute模式
```text
其他的Agent的运行模式。先规划再执行的模式。主要包含以下几个模块：
1. Agent主程序
2. Plan模型
3. Re-Plan模型（可以和上面的模型为同一个）
4. 执行Agent

eg:
Q：今年澳网男子冠军家乡在哪？
Agent主程序：问题发给 Plan模型 去生成执行步骤
Plan模型：生成计划发给 执行Agent。（比如：1.查询当前日期；2.查询对应日期的澳网男子冠军名字；3.查询这位冠军的家乡）
执行Agent：执行第一步，查询当前日期。获取结果发送给 Agent主程序。
Agent主程序：将执行计划、执行记录发给 Re-Plan模型。
Re-Plan模型：根据获取到的结果生成新的执行计划发给 Agent主程序（1. 查询2025年澳网男子冠军名字；2. 查询这位冠军的家乡）
Agent主程序：将计划中的第一步发给 执行Agent（查询2025年澳网男子冠军名字）。
执行Agent：获取到冠军名字xxx返回给 Agent主程序。
Agent主程序：将执行计划、执行记录发给 Re-Plan模型。
Re-Plan模型：根据执行计划和执行记录生成新的执行计划发给 Agent主程序（1. 查询xxx的家乡）。
Agent主程序：将计划中的第一步发给 执行Agent（查询xxx的家乡）。
执行Agent：获取到地名 bbb 返回给 Agent主程序。
Agent主程序：将执行计划、执行记录发给 Re-Plan模型。
Re-Plan模型：检查发现没有计划执行了，返回结果 Agent主程序。
Agent主程序：返回最终答案。
```
